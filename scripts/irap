#!/bin/sh
#; -*- mode: Makefile;-*-
#the next line restarts using\
exec make --warn-undefined-variables -Rf "$0"  ${1+"$@"} 
# send the standard output to a log file --quiet
# exec bash -c 'make  --warn-undefined-variables -Rf "$0" ${1+"$@"}  | tee  `date "+%d%m%y%H%M"`.log" - 
# =========================================================
# Copyright 2012-2015,  Nuno A. Fonseca (nuno dot fonseca at gmail dot com)
#
# This file is part of iRAP.
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with iRAP.  If not, see <http://www.gnu.org/licenses/>.
#
#
#    $Id: scripts/irap 0.1.1 Nuno Fonseca Fri Dec 21 01:07:37 2012$
# =========================================================

# Goals: flexible pipeline that can perform checkpoints, easily exchange of components
#
# Note that this program is constantly evolving - we are trying to maintain the documentation up to date.
#
#This program will perform: 
#  - setup/stage0: check all directories and data files are present and at the expected place 
#        --- called with "setup"
#  - stage1: quality filtering and reporting: check fastq file quality and report
#        --- called with "quality_filtering_and_report"
#  - stage2: mapping: to the transcriptome or to the genome (the former: to come)
#        --- called by the mapper's name, e.g. "bwa_mapping", "tophat_mapping", etc.
#  - stage3: estimate gene expression 
#        --- called with the assembler's name, e.g. "cufflinks_assemble", "mmseq_assemble", etc.                                                                                                                         
#  - stage4: estimate differential expression 
#        --- called by "DE"
#
# Tools to map, calculate gene expression or differential expression will vary so are not documented.
#
#
# The file requires a config file
# Typical command:
#     - irap conf=my_conf_file.conf
#     - irap name=study_name species=my_species reference=DNA_species_file 
#            E.g. irap name=ibm_fastqc data_dir=/net/isilon5/ma/home/kmegy/iRAP/irap/data species=homo_sapiens reference=Homo_sapiens.GRCh37.66.dna.fa.gz
#
#To run a specific stage, provide its name as parameter: 
#     - irap conf=my_conf_file.conf quality_filtering_and_report
#
#It is recommended to run the "setup" stage before any specific single task 
# to ensure the directory structure is set properly. 
#No need to do this if running the whole analysis as setup WILL be run by default.
#
# Note:
#   - libnames in conf file should not end in _(1/2)
#
###############################################################
# disable deletion of temporary files
.SECONDARY: 
.ONESHELL:

SHELL=bash
##################
# Setup some paths
# path to script
path=.
path?=$(shell if which irap >/dev/null 2>/dev/null; then dirname $(MAKEFILE_LIST); else dirname `which irap`; fi)

ifdef path
 PATH:=$(path):$(PATH)
endif

# Requires make 4.1 or above
VERSION_OK=$(shell if [ `make --version|head -n 1 | cut -f3 -d\ ` \< 4.1 ]; then echo 0; else echo 1; fi )
ifeq ($(VERSION_OK),0)
 $(error make version needs to be 4.1 or above)
endif

irap_path:=$(shell dirname `which irap`)
################################################################################
# Auxiliary functions
################################################################################

# Information messages
define p_info=
$(info $(shell date "+%H:%M:%S %d/%m/%Y * ") $(1))
endef

# Error messages
define p_error=
$(info $(shell date "+%H:%M:%S %d/%m/%Y") * ERROR: $(1)) && $(error Fatal error)
endef

# check if the parameter has a value - prints an error if not
ifdef verbose
define check_ok=
$(if $($(1)),$(call p_info, *	$(1)=$($(1))),$(p_error Missing $(1)))
endef
else
define check_ok=
$(if $($(1)),,$(p_error Missing $(1)))
endef
endif

# complain if a file does not exist and exit
file_exists=$(if  $(realpath $(1)),,$(call p_error,$(1) not found))

#  check if a variable  $(1) is defined - return the variable name if it is defined or empty otherwise
is_defined=$(if $(subst undefined,,$(origin $(1))),$(1),)

# ensure that the dir name starts and ends with a /
check_libdir_ok=$(if $(call is_defined,$(1)_dir),$(patsubst %/,%,$($(1)_dir))/,$(patsubst %/,%,$(def_lib_dir))/)

# *****************
# Stranded data
# return y if the strand info was provided
lib_strand_info=$(if $(call is_defined,$(1)_strand),y,)

# strand value
VALID_STRAND_OPTIONS=first second both
# return non empty if option is invalid
strand_value_ok=$(if $(filter $($(1)),$(VALID_STRAND_OPTIONS)),invalid option $($(1)) for $(1),)

# check if stranded information is ok
check_libstrand_ok=$(if $(call is_defined,$(1)_strand),$(if $(call strand_value_ok,$(1)_strand),$(call set_has_stranded_data,$(1)) $($(1)_strand),$(call p_error,Invalid strand option for lib $(1) - $($(1)_strand))))

# validate the read group id info
check_rgid_ok=$(call get_rgid,$(1))
get_rgid=$(if $(call is_defined,$(1)_rgid),$($(1)_rgid),)

# sam header
# add @rg if not defined
check_sheader_ok=$(if $(call is_defined,$(1)_shl),$($(1)_shl),$(if $($(1)_rgid),'@RG	ID:$($(1)_rgid)',))

has_stranded_data=no
set_has_stranded_data=$(if $(filter both,$($(1)_strand)),,$(eval has_stranded_data=yes))


# ****************
# Paths
# get the path for a filtered fastq file
lib2filt_folder=$(name)/data/$($(1)_dir)
# get the path for a bam file
lib2bam_folder=$(name)/$(mapper)/$($(1)_dir)
#
lib2snp_folder=$(name)/$(mapper)/$($(1)_dir)
#
lib2quant_folder=$(name)/$(mapper)/$(quant_method)/$($(1)_dir)
#
lib2fusion_folder=$(name)/$(mapper)/$(fusion_method)/$($(1)_dir)

# check if a parameter is defined
check_param_ok=$(if $(call is_defined,$(strip $(1))),$(info *	$(1)=$($(1))),$(error * Missing -$(1)-))

# check  contrast name
# 1 - param 2-param_name
check_name=$(if $(shell echo $(1)|sed "s/[0-9]*//g"),,$(error * Invalid $(2) $(1)))


# the library name should be different from the prefix of the fastq files
# ex. of an invalid library name: lib1=lib1.fastq
# 1=libname
check_se_libname_ok=$(if $(subst $(1).fastq,,$($(1))),, $(error * Invalid libname $(1)))
check_pe_libname_ok=$(if $(strip $(subst $(1)_2.fastq,,$(subst $(1)_1.fastq,,$($(1))))), ,$(error * Invalid libname $(1)))

# 1 - lib
# 2 - bam
define convert_bam2sefastq=
$(call file_exists,$(2))
$(eval override $(1):=$(notdir $(basename $(2))).fastq)
endef
define convert_bam2pefastq=
$(call file_exists,$(2))
$(eval override $(1):=$(notdir $(basename $(2)))_1.fastq $(notdir $(basename $(2)))_2.fastq)
endef


################################################################################
# Variables
################################################################################
ifndef debug	
 debug=1
p_debug=
else
p_debug=$(info DEBUG:$(1))
endif

ifndef pe
 pe=
else
override pe:=$(sort $(pe))
endif

ifndef se
 se=
else
override se:=$(sort $(se))
endif

# remove duplicates

#************************
#Version and license info
pname=IRAP
version=0.6.2p1
contact=Developed by Nuno Fonseca (authorname (at) acm.org)
license=This pipeline is distributed  under the terms of the GNU General Public License 3


################################################################################
# Default values
################################################################################
def_gse_tool=none

# max. memory (in MB)
def_max_mem=6000

#Contamination file
def_cont_index=$(data_dir)/contamination/e_coli

#Default number of threads to run on a computer farm
def_max_threads=1

#Minimal base quality accepted
def_min_read_quality=10

#Trim all reads to the minimum read size after quality trimming - y/n
def_trim_reads=y

# Quality filtering - on/off/none (alias: qc)
def_qual_filtering=on

#Software for mapping (reads -> genome/transcriptome)
def_mapper=tophat2
def_mapper_splicing=yes

#Software for differential expression
def_de_method=none

#Is the experiment designed to compare the results of different mappers? yes|no => undef conditions|contrasts
def_mapper_comparison=no

# default method to count reads mapped to features (genes, exons, ...)
def_quant_method=htseq2

# default method to normalize the counts
def_quant_norm_method=deseq

# produce quantification per exon? default is gene level or transcript level depending on the method used
def_exon_quant=n
def_transcript_quant=n

# maximum number of hits reported by the mapper
def_max_hits=10

# fix NH flags in bam files
def_fix_NH=y

# use only a subset of the genes in the DE analysis (y|n)
def_de_annot_genes_only=n

# Htseq - produce a sam file with annotations?y/n
htseq_sam_output_def=n

# DE
def_de_pvalue_cutoff=0.05
def_de_num_genes_per_table=300

#def_annot_tsv=auto
def_annot_tsv=off

def_lib_dir=

CSS_FILE?=irap.css
################################################################################
# START!
$(info *****************************************************)
$(info * $(pname) $(version))
$(info * $(contact))
$(info * $(license))
$(info *)

$(info * Initializing...)


###############################################
# Load configuration (mandatory)
ifdef conf
 $(call file_exists,$(conf))
 $(info * Trying to load configuration file $(conf)...)
 include $(conf)
 $(info * Configuration loaded.)
else
 $(call p_error,Configuration file missing)
endif

# load library specific information
ifdef lib.info
lib_info=$(lib.info)
endif

ifdef lib_info
 $(call file_exists,$(lib_info))
 $(info * Trying to load information about the libraries - file $(lib_info)...)
 include $(lib_info)
 $(info * Information about the libraries loaded.)
endif

###############################################
# Load some definitions
include $(irap_path)/../aux/mk/irap_defs.mk

###############################################################
# Check and validate the parameters values
# fastq files -> pair-end, single-end or both

$(info * )
$(info * Required Parameters:)

#***********************
# Name of the experiment
ifndef name
 $(call p_error, missing argument name!)
else
 $(info *	name=$(name))
endif

#************************
# data_dir Data directory (directory where the data is expected to be)
# Directory organization
# data_dir/reference/species/(fasta+(cdna+gtf))
# data_dir/raw_data/$(raw_folder)/

# check if data dir exists and structure is OK
# TODO
ifndef data_dir
 $(call p_error,missing argument data_dir)
endif


$(info *	data_dir=$(data_dir))
$(call file_exists,$(data_dir))

#********
# Species
ifndef species
 $(call p_error,missing argument species)
else
 $(info *	species=$(species))
endif

#****************
# raw data folder
ifndef raw_folder
 raw_folder=$(species)
endif

#**********************
# Reference genome file
ifndef reference
 $(call p_error,missing argument reference)
endif

# 
reference_dir:=$(abspath $(data_dir)/reference/$(species))
reference_abspath:=$(abspath $(reference_dir)/$(subst .gz,,$(reference)))
reference_prefix:=$(reference_abspath)
# remove .gz if the file is gziped...the creation of the uncompress file is automatic

$(info *	reference=$(reference))
$(call file_exists,$(reference_dir)/$(reference))
#********* 
# GTF file
ifndef gtf_file
 gtf_file?=$(subst .fa,.gtf,$(reference))
endif

# remove .gz if the file is gziped...the creation of the uncompress file is automatic
gtf_file_dir:=$(abspath $(data_dir)/reference/$(species))
gtf_file_abspath:=$(abspath $(gtf_file_dir)/$(subst .gz,,$(gtf_file)))

$(info *       gtf_file  = $(gtf_file))
$(call file_exists,$(gtf_file_dir)/$(gtf_file))

# ************
# spikein data

ifdef spikein_fasta
spikein_data=y
$(info *	spikein_data=y)
spikein_fasta_abspath:=$(data_dir)/raw_data/$(raw_folder)/$(spikein_fasta)
$(call file_exists,$(spikein_fasta_abspath))
# remove .gz
override spikein_fasta_abspath:=$(data_dir)/raw_data/$(raw_folder)/$(subst .gz,,$(spikein_fasta))
# gtf and fasta files
# new reference file cannot be shared across experiments
reference_dir:=$(name)/data
user_reference_abspath:=$(reference_abspath)
# ref: ref_prefix.spike.fa
override reference_abspath:=$(name)/data/$(patsubst %.fa,%.spike.fa,$(patsubst %.fasta,%.spike.fasta,$(subst .gz,,$(reference))))
reference_prefix=$(reference_abspath)
#
gtf_file_dir:=$(name)/data
user_gtf_abspath:=$(gtf_file_abspath)
gtf_file_abspath:=$(name)/data/$(patsubst %.gtf,%.spike.gtf,$(subst .gz,,$(gtf_file)))
spikein_gtf_file:=$(gtf_file_dir)/spike.gtf
override gtf_file:=$(notdir $(gtf_file_abspath))

#
$(warning Currently spikein data is not explored when performing differential expression analysis)
endif


# ****************
# single cell
ifndef single_cell
single_cell=n
endif

ifeq ($(single_cell),y)
$(info *	single_cell=y)
ifndef spikein_data
$(call p_error,spikein_fasta parameter needs to be provided when analysing single cell data)
endif
endif

# ****************
# file with the junctions (as used by tophat)
# offset=0
# includes 1 base of the exons
juncs_file_abspath:=$(subst .gz,,$(gtf_file_abspath)).juncs
juncs_file:=$(notdir $(juncs_file_abspath))



ifndef gff3_file
# GFF3 file obtained from the gtf file
gff3_file_abspath:=$(name)/data/$(patsubst %.gtf,%.gff3,$(subst .gz,,$(gtf_file)))
else
gff3_file_abspath:=$(subst .gz,,$(gff3_file))
endif

gff3_file:=$(notdir $(gff3_file_abspath))
$(info *       gff3_file  = $(gff3_file_abspath))


# mapping (exon/transcript to gene) file obtained from the gtf file
feat_mapping_file?=$(subst .gz,,$(subst .gtf,.mapping.Rdata,$(gtf_file_abspath)))

#**********
# cDNA file
ifndef cdna_file
 cdna_file?=$(subst .dna.fa,.cdna.all.fa,$(reference))
 ifeq ($(cdna_file),$(reference))
   cdna_file=$(subst .fa,.cdna.all.fa,$(reference))
 endif
endif
cdna_dir:=$(abspath $(data_dir)/reference/$(species))
cdna_file_abspath=$(abspath $(cdna_dir)/$(subst .gz,,$(cdna_file)))

#$(info *       CDNA = $(cdna_file))
# TODO: only report an error if the file is really needed
#$(call file_exists,$(cdna_dir)/$(cdna_file))


#trans_file?=$(abspath $(data_dir)/reference/$(species)/$(shell echo $(reference)|sed "s/.dna.fa/.trans.fa/" | sed "s/.gz//"))
trans_file?=$(cdna_file_abspath)
$(info *       Transcripts = $(trans_file))
#$(call file_exists,$(trans_file))


refgeneclass_file=$(subst .gz,,$(gtf_file_abspath)).gene_class.txt
refgeneannot_file=$(subst .gtf,,$(subst .gz,,$(gtf_file_abspath))).gene_annot.tsv

#************
# FASTQ files
# SE reads
ifdef se
 $(info *	se=$(se))
 #$(foreach l,$(se),$(info $(l)=$($(l)))) 
 # check if fastq file is in a different directory
 $(foreach l,$(se),$(eval $(l)_dir=$(call check_libdir_ok,$(l))))
 $(foreach l,$(se),$(eval $(l)_strand=$(call check_libstrand_ok,$(l)))) 
# read group id
 $(foreach l,$(se),$(eval $(l)_rgid=$(call check_rgid_ok,$(l)))) 
# sam header (may/should include @RG)
 $(foreach l,$(se),$(eval $(l)_shl=$(call check_sheader_ok,$(l)))) 
 #$(foreach l,$(se),$(info $(l)_dir=$($(l)_dir)))
 #$(foreach l,$(se),$(info $(l)_dir=$($(l)_dir)))
 #$(foreach l,$(se),$(info $(l)_dir=$(call check_libdir_ok,$(l))))
 $(foreach l,$(se),$(call check_se_libname_ok,$(l)))
 $(foreach l,$(se),$(call check_param_ok,$(l)_rs))
 $(foreach l,$(se),$(call check_param_ok,$(l)_qual))
 ifile_given=1
endif

# PE files (libraries)
# lib=A B C
# 
# A=""
ifdef pe
 map=$(foreach a,$(2),$(abspath $(call $(1),$(a))))
 deref=$($1)
 fastq_files?=$(call map, deref, $(pe))
 $(info *	pe=$(pe))
 # $(info * debug * fastq_files=$(fastq_files))
 # check the definition of 
 #  insert size
 #  sd
 #  read size
 #  read group id
 #  shl (sam header lines)
 # for each lib
 rs_list=
 set_rs_list=$(eval rs_list+= $($(1)))
 $(foreach l,$(pe),$(call check_pe_libname_ok,$(l)))
 $(foreach l,$(pe),$(eval $(l)_dir=$(call check_libdir_ok,$(l))))
 $(foreach l,$(pe),$(eval $(l)_strand=$(call check_libstrand_ok,$(l))))
# read group id
 $(foreach l,$(pe),$(eval $(l)_rgid=$(call check_rgid_ok,$(l)))) 
# sam header lines (may/should include @RG)
 $(foreach l,$(pe),$(eval $(l)_shl=$(call check_sheader_ok,$(l)))) 
 #$(foreach l,$(pe),$(info $(l)_dir=$($(l)_dir)))
 $(foreach l,$(pe),$(call check_param_ok,$(l)_sd))
 $(foreach l,$(pe),$(call check_param_ok,$(l)_ins))
 $(foreach l,$(pe),$(call check_param_ok,$(l)_rs))
 $(foreach l,$(pe),$(call check_param_ok,$(l)_qual))
 $(foreach l,$(pe),$(call set_rs_list,$(l)_rs))
 #$(foreach l,$(pe),$(call check_param_ok,$(l)_mp))
 ifile_given=1
endif

#$(call p_info,has_stranded_data=$(has_stranded_data))

ifndef ifile_given
$(warning pe parameter or se parameter should be defined and non-empty)
endif



#***********
# Contrasts
#***********

# backward compatibility
#ifdef conditions
#endif


ifdef contrasts
 $(info *	contrasts=$(contrasts))
# check contrast/group names
 $(foreach l,$(contrasts),$(call check_name,$(l),contrast);$(foreach g,$($(l)),$(call check_name,$(g),group/condition)))
 $(foreach l,$(contrasts),$(info *      $(l)=$($(l)));$(foreach g,$($(l)),$(call check_param_ok,$(g))))
else
contrasts=
endif


# Contrasts
# Ex.
# contrasts=contrast1 contrast2
# contrast1=g1 g2
# g1=Lib1 Lib2
# g2=Lib3 Lib4

########
# groups
# list of groups defined (only used during html report generation)
# ex.
# groups=group1 group2 group3 
ifndef groups
$(info *	 groups=  parameter not defined, this should be defined if you intend to generate an HTML report for the inferred gene/level/transcript quantification)
groups=
else
$(foreach g,$(groups),$(call check_param_ok,$(g)))
$(info *	groups=$(groups))
endif

#*********************
# Technical replicates
#*********************

# ex. technical.replicates=SE1,SE2;PE1,PE3,PE4
# means that there are two groups of tech. replicates (separated by;), group 1 composed by SE1 and SE2  and group2 composed by PE1,PE3 and PE4.
ifndef technical.replicates
technical.replicates=
 $(info *	technical.replicates=NONE)
else
 $(info *	technical.replicates=$(technical.replicates))
 # validate the libraries names
 comma=,
 quote="
 $(foreach  l,$(subst $(quote), ,$(subst $(comma), ,$(subst ;, ,$(technical.replicates)))),$(call check_param_ok,$(strip $(l))))
endif
#" 


#####################
# Other Optional parameters
#####################
$(info * )
$(info * Optional Parameters:)

#********
# Threads
#********
ifndef max_threads
 max_threads=$(def_max_threads)
endif
$(info *	max_threads=$(max_threads))

#********************
# Temporary directory
#********************
# 
ifndef tmp_dir
 tmp_dir=$(data_dir)/tmp
endif

#$(shell mkdir -p tmp_dir)
$(info *	tmp_dir=$(tmp_dir) (temporary directory))

#******************
# Quality filtering
#******************
# on|off|report|none
ifdef qc
 qual_filtering=$(qc)
endif

ifndef qual_filtering
 qual_filtering=$(def_qual_filtering)
endif

# alias
ifndef qc
qc=$(qual_filtering)
endif

ifndef trim_reads
 trim_reads=$(def_trim_reads)
endif

#*************
# Min. quality
#*************
ifdef min_read_quality
 ifeq ($(strip $(min_read_quality)),)
  undefine min_read_quality
 endif
endif

ifndef min_read_quality
 min_read_quality=$(def_min_read_quality)
endif


#*******************
# Contamination file
#*******************
ifndef cont_index
 cont_index=$(def_cont_index)
endif

#**************
# Mapper to use
#**************
ifndef mapper
 mapper=$(def_mapper)
endif
$(info *	mapper=$(mapper))

# gems
SUPPORTED_MAPPERS=tophat1 tophat2 smalt gsnap soapsplice bwa1 bwa2 bowtie1 bowtie2 gem star osa mapsplice
ifeq (,$(filter $(mapper),$(SUPPORTED_MAPPERS)))
$(call p_info,[ERROR] Mapping)
$(error $(mapper) not implemented)
endif

mapper:=$(strip $(mapper))
#***************************
# Quantification/Transcr. assembly program
#***************************
# Note: only reference based assemblers should be supported
# assembler (deprecated)
ifdef quant_method
undefine assembler
endif

ifdef assembler
ifndef quant_method
quant_method=$(assembler)
endif
ifndef quant_norm_method
quant_norm_method=$(assembler)
endif
endif

ifndef quant_norm_method
ifndef quant_method
quant_norm_method=$(def_quant_norm_method)
else
quant_norm_method=none
endif
endif


###########################
# Method to count reads mapped to features (genes, exons, ...)
###########################
ifndef quant_method
 quant_method:=$(def_quant_method)
endif

#SUPPORTED_QUANT_METHODS=basic htseq1 htseq2 cufflinks1 cufflinks2 cufflinks1_nd cufflinks2_nd scripture flux_cap
SUPPORTED_QUANT_METHODS=basic htseq1 htseq2 cufflinks1 cufflinks2 cufflinks1_nd cufflinks2_nd scripture flux_cap nurd stringtie stringtie_nd

# methods that produce transcript level quantification by default
TRANS_QUANT_METHODS=flux_cap cufflinks1 cufflinks2 cufflinks1_nd cufflinks2_nd nurd stringtie stringtie_nd

#rsem isoem sailfish bitseq
ifeq (,$(filter $(quant_method),$(SUPPORTED_QUANT_METHODS) none))
$(call p_info,[ERROR] quant_method)
$(error $(quant_method) not supported)
endif

quant_method:=$(strip $(quant_method))
$(info *	quant_method=$(quant_method))

ifndef exon_quant
exon_quant=$(def_exon_quant)
endif

ifndef transcript_quant
transcript_quant=$(def_transcript_quant)
endif

ifneq (,$(filter $(quant_method),$(TRANS_QUANT_METHODS)))
$(info Enabling transcript_quant since  $(quant_method) supports it by default)
override transcript_quant=y
endif


$(info *	exon_quant=$(exon_quant))
$(info *	transcript_quant=$(transcript_quant))

ifeq ($(exon_quant),y) 
$(info Exon quantification requires that all exons in the gtf file have an exon_id attribute)
endif
ifndef gtf_file_wexonid
gtf_file_wexonid=$(gtf_file_abspath)
#$(gtf_file_wexonid)=$(gtf_file_abspath).exon_id.gtf
endif

##################################
# method to normalize the counts
##################################
#ifndef quant_norm_method
  ifneq (,$(filter flux_cap,$(quant_method)))
   $(call info,*	overriding quant_norm_method!)
   override quant_norm_method=$(quant_method)
  else
   ifneq (,$(findstring cufflinks,$(quant_method)))
    $(call info,*	overriding quant_norm_method!)
    override quant_norm_method=$(quant_method)
   else
    ifneq (,$(findstring nurd,$(quant_method)))
     $(call info,*	overriding quant_norm_method!)
     override quant_norm_method=$(quant_method)
    else
     ifneq (,$(findstring stringtie,$(quant_method)))
      $(call info,*	overriding quant_norm_method!)
      override quant_norm_method=$(quant_method)
     else
      quant_norm_method=$(def_quant_norm_method)
     endif
    endif
   endif
  endif
#endif
SUPPORTED_COUNT_NMETHODS=cufflinks1 cufflinks2 cufflinks1_nd cufflinks2_nd deseq flux_cap  nurd stringtie
ifeq (,$(filter $(quant_norm_method),none $(SUPPORTED_COUNT_NMETHODS)))
$(call p_info,[ERROR] quant_norm_method)
$(error $(quant_norm_method) not supported)
endif

## override normalization option based on the quantification method
ifneq (,$(findstring cufflinks,$(quant_method)))
$(call info,*	overriding quant_norm_method!)
override quant_norm_method=$(quant_method)
endif

ifneq (,$(filter flux_cap,$(quant_method)))
$(call info,*	overriding quant_norm_method!)
override quant_norm_method=$(quant_method)
endif

ifneq (,$(filter nurd,$(quant_method)))
$(call info,*	overriding quant_norm_method!)
override quant_norm_method=nurd
endif

$(info *	quant_norm_method=$(quant_norm_method))

#******************************
# Use unspliced mapping: yes/no 
#******************************
# this option is going to be removed in the future
ifndef mapper_splicing
 mapper_splicing=$(def_mapper_splicing)
endif
$(info *	mapper_splicing=$(mapper_splicing))

#********************
# DE
#********************
ifndef de_method
ifdef compare
de_method=$(compare)
endif
endif

ifndef de_method
 de_method=$(def_de_method)
endif

SUPPORTED_DE_METHODS=cuffdiff1 cuffdiff2 cuffdiff1_nd cuffdiff2_nd deseq edger voom deseq2
ifeq (,$(filter $(de_method),none $(SUPPORTED_DE_METHODS)))
$(call p_info,[ERROR] de_method)
$(error $(de_method) not supported)
endif

de_method:=$(strip $(de_method))
$(info *	de_method=$(de_method))

ifndef de_pvalue_cutoff=
 de_pvalue_cutoff=$(def_de_pvalue_cutoff)
endif

ifndef de_num_genes_per_table
de_num_genes_per_table=$(def_de_num_genes_per_table)
endif

# TSV file
# format (fields may be missing with NA)- (gene) ID is mandatory and should match the one given in the gtf file
# "ID","Name","locus","source","lname","GO","GOterm","KEGG"
ifndef annot_tsv
annot_tsv=$(def_annot_tsv)
#else
# TODO: check if file format is ok and file !=auto
endif

ifeq (auto,$(annot_tsv)) 
annot_tsv=$(name)/data/gene.annot.tsv
endif


ifeq (off,$(annot_tsv)) 
override annot_tsv:=$(name)/data/empty.gene.annot.tsv
endif


ifndef de_annot_genes_only
de_annot_genes_only=$(def_de_annot_genes_only)
endif

#$(info annot_tsv=$(annot_tsv))

#************
# Constraints
#************
ifdef compare_mappers
 ifdef conditions
  $(error Incompatible options: compare_mappers and conditions)
 endif
endif



ifeq ($(mapper_splicing),no)
 files_indexed=$(trans_file)
else
# word 1 = reference 
 files_indexed=$(reference_prefix) $(gtf_file_abspath)
endif

ifeq (y,$(de_annot_genes_only))
 ifeq ($(de_method),cuffdiff1)
  $(error Incompatible options: de_annot_genes_only & $(quant_method))
 endif
 ifeq ($(de_method),cuffdiff2)
  $(error Incompatible options: de_annot_genes_only & $(quant_method))
 endif
endif

##########
# other options

# maximum number of mappings allowed for each read
ifndef max_hits
 max_hits=$(def_max_hits)
endif

# fix NH flag in BAM files (y,n)
ifndef fix_NH
 fix_NH=$(def_fix_NH)
endif

#
# Htseq - produce a sam file with annotations?y/n
ifndef htseq_sam_output
htseq_sam_output=$(htseq_sam_output_def)
endif

ifeq ($(htseq_sam_output),y)
htseq_sam_output=
endif
#
# mem in MB
ifndef max_mem
max_mem=$(def_max_mem)
endif

# max memory in GB
max_mem_gb:=$(shell expr $(max_mem) \/ 1000)

# set memory (in bytes) to 65% of the max. memory available
#ifndef SAMTOOLS_SORT_MEM
# SAMTOOLS_SORT_MEM:=`expr $(max_mem) \* 1000000 \* 65 \/ 100`
#endif


# samtools 1.x
ifndef SAMTOOLS_SORT_MEM
 SAMTOOLS_SORT_MEM:=$(shell bash -c "expr $(max_mem_gb) \* 75 \/ 100")G
endif


ifndef feat_length
feat_length=$(name)/data/lengths.Rdata
endif


###############################################################################
# When the number of libraries is greater than BIG_LIM then pass the arguments
# to some scripts from stdin
ifndef BIG_LIM
BIG_LIM:=400
endif

ifeq ($(shell expr $(words $(se) $(pe)) \<  $(BIG_LIM)),0)
# too many libs to be able to pass them as an argument
$(call p_info, Big number of libraries mode (>$(BIG_LIM)))
BIG_EXP=1
# cmd=$1
# out_file=$2
# args=$3
define pass_args_stdin=
$(call args2file,$(2).in,$(3)) cat $(2).in | $(1) -stdin && rm -f $(2).in
endef

else
BIG_EXP=0
#$(call p_info, Small number of libraries mode)
# cmd=$1
# out_file=$2
# args=$3
define pass_args_stdin=
$(1) $(3) 
endef

endif


################################################################################
# Make stuff
phony_targets=
silent_targets= 

empty:=
space:=$(empty) $(empty)#
################################################################################
# AUXILIARY FUNCTIONS
################################################################################

# FALSE=empty

# return a string in the form of group1,group2,...
define groups2str=
$(call spaces2commas,$(call groupsnames))
endef

define remove_spaces=
$(subst $(space),,$(1))
endef

define spaces2commas=
$(shell echo $(1)|tr " " ",")
endef

#$(sort $(strip $(foreach l,$(groups),$(foreach g,$($(l)),$(g)))))
define groupsnames=
$(sort $(strip $(foreach l,$(groups),$(l) )))
endef


# return groups definition
define groupsdef2str=
$(call remove_spaces,$(foreach g,$(call groupsnames),$(call spaces2commas,$(strip $($(g))));))
endef

define libname2ofastq=
$($(1))
endef

# fix the libname by excluding _1 and _2 from PE files
define fix_libname=
$(if $(call valid_libname,$(1)),$(1),$(call get_lib_name,$(1)))
endef

define valid_libname=
$(if $(filter $(strip $(1)),$(pe) $(se)),y)
endef

# 1 - libname
# return y if is PE '' otherwise
define is_pe_lib=
$(if $(filter $(strip $(1)),$(pe)),y)
endef

# 1-libname
# path to the filtered fastq files 
define libname2fastq=
$(if $(call is_pe_lib,$(1)),$(call lib2filt_folder,$(1))$(1)_1.f.fastq $(call lib2filt_folder,$(1))$(1)_2.f.fastq,$(call lib2filt_folder,$(1))$(1).f.fastq)
endef

# 1-libname
define bam_file_for_lib=
$(if $(call is_pe_lib,$(1)),$(1).pe.hits.bam,$(1).se.hits.bam)
endef


define get_lib_name=
$(if $(filter $(1),$(se)),$(1),$(if $(findstring $(patsubst %_1,%,$(1)),$(pe)),$(patsubst %_1,%,$(1)),$(if $(findstring $(patsubst %_2,%,$(1)),$(pe)),$(patsubst %_2,%,$(1)),$(1))))
endef

# 1 -lib
define path2lib_bam=
$(call lib2bam_folder,$(1))/$(call bam_file_for_lib,$(1))
endef

# 1-group
define  get_group_bam_files=
$(foreach l,$($(1)), $(call path2lib_bam,$(l)))
endef

# save all variables defined in Make (filename)
define vars2file=
$(file > $(1))
$(foreach ivar,$(.VARIABLES),$(if $(filter $(origin $(ivar)),'file' 'command line',$(file >> $(1),$(ivar)=$($(ivar))))))
endef
#$(call vars2file,/tmp/lixo)

# the bam file names of each group are concatened using ,
define  get_contrast_bam_files=
$(foreach c,$($(1)), $(shell echo $(call get_group_bam_files,$(c)) | sed "s/ /,/g"))
endef

# 
define get_de_annot=
$(if $(annot_tsv),--annotation $(annot_tsv),)
endef

# DE options
define get_de_annot_genes_only=
$(if $(subst y,,$(de_annot_genes_only)),,--annot-genes-only)
endef

#1
define filename2libname=
$(foreach l,$(se) $(pe),$(if $(filter $(l).,$(1)),$(l)))
endef

# 1 tsv filename
#  exon, gene or CDS?
# DE filename to Analysis level
define DEfilename2AL=
$(if $(findstring .genes_de,$(1)),gene,$(if $(findstring .exons_de,$(1)),exon,CDS))
endef

define DEfilepath2demethod=
$(shell basename `dirname $(1)`)
endef

# sam/bam cat
# avoid samtools cat if there is only a file
# $(1)=files
define samcat=
$(if $(strip $(word 2,$(1))),samtools cat -o - $(1),cat $(1))
endef

# two line empty file (ensure that size !=0 and # lines >1)
# 1 - filename
define empty_file=
echo Empty	Empty > $(1) && echo Empty	Empty  >> $(1)
endef

# 1 - filename
# return y if it is an empty file or '' otherwise
define is_empty_file=
$(if  $(realpath $(1)),$(if $(shell head -n 1 $(1) | grep   Empty),y))
endef

define zero_lines_file=
$(if $(realpath $(1)),$(if  $(shell wc -l $(1)|cut -f 1 -d\ |sed "s/^0$//",,no)),)
endef
#1-file
#2-args
define args2file=
 $(file > $(1),$(2))
 $(shell echo >> $(1))
endef
# add the new line in the end

####################
###################
# 
# $(1) var name
cached_vars=

cached_vars_file=$(name)/cached_vars.mk
ifndef use_cached_vars
use_cached_vars=n
endif

define cached_var=
$(if $(call is_defined,$(1)), $(call p_debug,cache hit $(1)), $(call set_$(1)) $(call p_debug,cache miss $(1)) $(eval cached_vars+= $(1))) $($(1))
endef

ifeq (use_cached_vars,y)
$(call file_exists,$(cached_vars_file))	
include $(cached_vars_file)
$(info [INFO] Loaded cached variables.)
endif

#
define list_cached_vars=
	$(foreach var,$(cached_vars) cached_vars, echo $(var)=$(strip $(call cached_var,$(var)));)
endef


################################################################################
# TODO: STAGE0
SETUP_DATA_FILES=
STAGE3_OUT_FILES=
STAGE3_S_TARGETS=

STAGE1_OUT_FILES=$(foreach p,$(se),$(call lib2filt_folder,$(p))$(p).f.fastq) $(foreach p,$(pe),$(call lib2filt_folder,$(p))$(p)_1.f.fastq)

STAGE2_OUT_FILES=$(foreach p,$(pe), $(call lib2bam_folder,$(p))$(p).pe.hits.bam) $(foreach s,$(se), $(call lib2bam_folder,$(s))$(s).se.hits.bam)

STAGE2BYNAME_OUT_FILES=$(foreach p,$(pe), $(call lib2bam_folder,$(p))$(p).pe.hits.byname.bam) $(foreach s,$(se), $(call lib2bam_folder,$(s))$(s).se.hits.byname.bam)

bam_files=$(STAGE2_OUT_FILES)

################################################################################
# Default target
all: setup quality_filtering_and_report mapping quantification DE GSE

################################################################################
# Load extra code
# Mapping
include $(irap_path)/../aux/mk/irap_map.mk
# JBrowse
include $(irap_path)/../aux/mk/irap_jbrowse.mk
# HTML Reporting
include $(irap_path)/../aux/mk/irap_report.mk
# Software used (versions and citations)
include $(irap_path)/../aux/mk/irap_citations.mk
# Quantification
include $(irap_path)/../aux/mk/irap_quant.mk
# DE
include $(irap_path)/../aux/mk/irap_de.mk
# Gene set enrichment analysis
include $(irap_path)/../aux/mk/irap_gse.mk



# Atlas (atlas specific stuff)
include $(irap_path)/../aux/mk/irap_atlas.mk

ifdef irap_devel
$(call p_info,Loading code under development)
# include under development features
include $(irap_path)/../aux/mk/irap_snp_indel_calling.mk
# Fusion
include $(irap_path)/../aux/mk/irap_fusion.mk
endif

# Check if the options provided are valid
ifeq (invalid,$(shell irap_paths $(mapper) $(quant_method) $(quant_norm_method) $(de_method) $(gse_tool) $(has_stranded_data)))
  $(error invalid combination mapper:$(mapper) -> quant_method:$(quant_method) -> quant_norm_method:$(quant_norm_method) -> de_method:$(de_method) for the given data)
endif

$(info *========================================================)

#################################################################################

index_files=$(call $(mapper)_index_filenames,$(word 1,$(files_indexed)),$(word 1,$(files_indexed)))

#*********************
# print all variables
ifdef debug
$(info DEBUG)
VARS2PRINT=reference_prefix gtf_file_abspath index_files files_indexed feat_mapping_file
$(foreach v,$(VARS2PRINT),$(info $v=$($v)))
endif
$(call p_info,[DONE] Initialization)


###################
# Quality Filtering
###################
read_qual_filter_common_params=tmp_dir=$(tmp_dir)  threads=$(max_threads)  qual_filtering=$(qual_filtering)  min_qual=$(min_read_quality) trim=$(trim_reads) cont_index=$(cont_index) 

define do_quality_filtering_and_report=
	irap_fastq_qc $(read_qual_filter_common_params) data_dir=$(data_dir)/raw_data/$(raw_folder)/$($(1)_dir) read_size=$($(1)_rs)   qual=$($(1)_qual) f="$($(1))" out_prefix=$(1) is_pe=$(call is_pe_lib,$(1)) out_dir=$(name)/data/$($(1)_dir) report_dir=$(name)/report/riq/$($(1)_dir)
endef

define do_quality_filtering_and_report_cleanup=
	irap_fastq_qc $(read_qual_filter_common_params) data_dir=$(data_dir)/raw_data/$(raw_folder)/$($(1)_dir) read_size=$($(1)_rs)  qual=$($(1)_qual) f="$($(1))" out_prefix=$(1) is_pe=$(call is_pe_lib,$(1)) out_dir=$(name)/data/$($(1)_dir) report_dir=$(name)/report/riq/$($(1)_dir) clean
endef

define not_empty=
	$(if $(call file_exists,$(1),),$(call p_error,File $(1) not found))
	$(if $(shell wc -l $(1)|cut -f 1 -d\ ),,$(call p_error,Empty file $(1)))
endef

################################################################################
#
################################################################################
# Generic file extension rules

# generate the fastq from BAM
# $(data_dir)/raw_data/$(species)/%.fastq: $(data_dir)/raw_data/$(species)/%.bam
# 	bamToFastq -i $^ -fq $@.tmp  && mv $@.tmp $@
# # pair-end data
# # bam files need to be sorted by name
# $(data_dir)/raw_data/$(species)/%_1.fastq $(data_dir)/raw_data/$(species)/%_2.fastq: $(data_dir)/raw_data/$(species)/%.bam
# 	$(call p_info,"Converting bam to fastq...note that the bam file needs to be sorted by name.")
# 	bamToFastq -i $^ -fq $*_1.fastq.tmp -fq2 $*_2.fastq.tmp && mv $*_1.fastq.tmp $*_1.fastq && mv $*_2.fastq.tmp $*_2.fastq

# uncompress rules
%.fa: %.fa.gz
	gunzip -c $< > $@.tmp && mv $@.tmp $@

%.fasta: %.fasta.gz
	gunzip -c $< > $@.tmp && mv $@.tmp $@

%.gtf: %.gtf.gz
	gunzip -c $< > $@.tmp && mv $@.tmp $@


ifdef spikein_data

$(reference_abspath): $(user_reference_abspath) $(spikein_fasta_abspath)
	cat $^ > $@.tmp && mv $@.tmp $@

$(spikein_gtf_file): $(spikein_fasta_abspath) 
	spikein_fasta2gtf.pl $< > $@.tmp && mv $@.tmp $@

$(gtf_file_abspath): $(user_gtf_abspath) $(spikein_gtf_file)
	cat $^ > $@.tmp && mv $@.tmp $@
endif


# give an error (should never happen)
#%.gtf:
#	$(call p_error, Missing gtf file $@)

%.gtf.checked: %.gtf
	irap_check_gtf $(gtf_file_abspath) &&  touch $@

%.gtf.bed: %.gtf
	gtf2bed.pl $< > $@

%.bam.bedGraph: %.bam $(name)/data/chr_sizes.txt
	bedtools  genomecov -ibam $< -bg -g $(name)/data/chr_sizes.txt > $@.tmp && mv $@.tmp $@

# gtf file with exon_id attribute
%.gtf.exon_id.gtf: %.gtf %.gtf.checked
	gtf_add_exon_id.pl $< > $@.tmp && mv $@.tmp $@


# sort a bam file by name and index
%.byname.bam: %.bam
	samtools sort -n -m $(SAMTOOLS_SORT_MEM) -T $*.byname.tmp -o $*.byname.tmp.bam $< && mv $*.byname.tmp.bam $@ 

# index a bam file
%.bam.bai: %.bam
	samtools index $<
# samtools 1.1 does not support the second argument :(
#	samtools index $< $@.tmp && mv $@.tmp $@

%.cram: %.bam
	samtools view -C -T $(reference_abspath) $< > $@.tmp && mv $@.tmp $@

#
# bigWig from bed 
# bed file needs to be sorted and converted to bedGraph
%.bw: %.bed $(name)/data/chr_sizes.txt
	tail -n +2 $< | cut -f 1,2,3,5 | sort -k1,1 -k2,2n  > $<.sorted.bed && \
	bedGraphToBigWig $<.sorted.bed $(name)/data/chr_sizes.txt $@.tmp && mv $@.tmp $@

# bigwig from bedgraph
%.bw: %.bedGraph $(name)/data/chr_sizes.txt
	bedGraphToBigWig $< $(name)/data/chr_sizes.txt $@.tmp && mv $@.tmp $@

define quant_levelFromFilename=
$(if $(findstring exons,$(1)),exon,$(if $(findstring genes,$(1)),gene,mRNA))
endef

# TSV (with feature value) is converted to bedGraph (http://genome.ucsc.edu/goldenPath/help/bedgraph.html)
# bedGraph generated is sorted
%.bedGraph: %.tsv $(gff3_file_abspath).csv $(name)/data/chr_sizes.txt
	tsv2bed.R $<  $(call quant_levelFromFilename,$*) $(gff3_file_abspath).csv $(name)/data/chr_sizes.txt | \
	sort -k1,1 -k2,2n | \
	bedtools merge -scores mean -i - > $@.tmp &&\
	mv $@.tmp $@

# give an error
%.cdna.fa:
	$(call p_error,Missing cdna file $@)

# feat_mapping_file
%.mapping.Rdata %.mapping_exons.tsv %.mapping_trans.tsv: %.gtf
	irap_gtf2mapping --gtf $(gtf_file_abspath) --out $*.mapping.tmp --cores $(max_threads) && \
	mv $*.mapping.tmp.Rdata $*.mapping.Rdata && \
	mv $*.mapping.tmp_exons.tsv $*.mapping_exons.tsv && \
	mv $*.mapping.tmp_trans.tsv $*.mapping_trans.tsv 

# rename does not work on some distros :(
#	rename $*.mapping.tmp $*.mapping $*.mapping.*


################################################################################
# stage 0 - setup/initialization
setup: setup_dirs setup_files

phony_targets+= setup setup_files

################################################################################
# Setup initial files
# file with the length of the features (gene, isoform, exon)
SETUP_DATA_FILES+=$(name)/data/gene_class.txt $(index_files) $(gtf_file_abspath).checked  $(gtf_file_abspath).exon_id.gtf $(juncs_file_abspath) $(name)/data/chr_sizes.txt    $(feat_length) $(annot_tsv) $(name)/data/introns.bed 


# No need to include these files since they are generated by some rule
# $(name)/data/introns.bed -> $(name)/data/genes.bed $(name)/data/exons.bed 
# $(gff3_file_abspath).csv -> $(gff3_file_abspath) 

setup_files: $(SETUP_DATA_FILES)

print_stage0_files: setup_dirs
	echo $(SETUP_DATA_FILES)

# index the reference
$(word 1,$(index_files)): $(files_indexed)
	$(call p_info,INDEXING)
	$(call run_$(mapper)_index,$(word 1,$(files_indexed)))
ifneq ($(word 2,$(index_files)),)
# index the annotation/transcriptome
$(word 2,$(index_files)): $(files_indexed)
	$(call p_info,INDEXING 2)
	$(call run_$(mapper)_index_annot,$(word 1,$(files_indexed)))
endif

# Create the file with gene classification by GeneId
$(refgeneclass_file): $(gtf_file_abspath)
	gtf2geneclass.sh $< > $@.tmp && mv $@.tmp  $@
#	$(error Missing required file $@)

# use tophat to generate the juncs file
# .gtf.juncs: .gtf
# note: the file may be empty
# in this case gtf2juncs returns an error that is ignored
$(juncs_file_abspath): $(gtf_file_abspath)
	tophat2_gtf_juncs $< > $@.tmp 
	mv $@.tmp $@

# .gff3.csv: .gff3
$(gff3_file_abspath): $(gtf_file_abspath)
	gtf2gff3.pl $< | sed "s/^chr//" |sed "s/^Chr//" > $@.tmp && mv $@.tmp $@

# 
$(gff3_file_abspath).csv: $(gff3_file_abspath)
	gff32csv.R $<   >   $@.tmp && mv $@.tmp $@


$(name)/data/gene_class.txt: $(refgeneclass_file)
	cp $< $@.tmp && mv $@.tmp $@

# file with chr\tchr_size
$(name)/data/chr_sizes.txt: $(reference_abspath)
	irap_chr_sizes.pl $< > $@.tmp && mv $@.tmp $@

$(reference_abspath).fai: $(reference_abspath)
	samtools faidx $<

#ifeq ($(realpath ,)
# automatically generated annot file
# avoid generating file if it is in the reference directory
# Create a Rdata file to speedup loading the matrix 
$(refgeneannot_file) $(refgeneannot_file).Rdata: $(gtf_file_abspath)
	irap_gtf2annot --gtf $< -s $(species) --cores $(max_threads) --rdata -o $@.tmp && mv $@.tmp $@ && mv $@.tmp.Rdata $@.Rdata

$(name)/data/gene.annot.tsv: $(refgeneannot_file) 
	cp $< $@.tmp && mv $@.tmp $@

$(name)/data/gene.annot.tsv.Rdata: $(refgeneannot_file).Rdata
	cp $< $@.tmp && mv $@.tmp $@
#endif

$(name)/data/empty.gene.annot.tsv: 
	echo '"ID","Name","locus","source","lname","GO","GOterm","KEGG"' | tr "," "\t" > $@

# collect genes, transcripts and exons lengths
# generate only once
$(gtf_file_abspath).lengths.Rdata: $(gtf_file_abspath)
	irap_gtf2featlength --gtf $< -o $@.tmp --cores $(max_threads) && mv $@.tmp.Rdata $@

$(name)/data/lengths.Rdata: $(gtf_file_abspath).lengths.Rdata
	cp $< $@.tmp && mv $@.tmp $@

# $(trans_file): 
# 	$(call p_error,Missing trans_file = $(trans_file))

################################################################################
# Setup directory structure
phony_targets+= setup_dirs

setup_dirs: $(tmp_dir) $(name)/report/riq/ $(if $(mapper),$(name)/$(mapper)/) $(name)/data/  $(if $(quant_method),$(name)/$(mapper)/$(quant_method)/)  $(if $(de_method),$(name)/$(mapper)/$(quant_method)/$(de_method)/)
	$(call p_info,[DONE] Directory structure created)

$(tmp_dir):
	mkdir -p $@

# really required?
#$(data_dir)/data:
#	mkdir -p $@


$(name)/data/:
	mkdir -p $@

$(name)/report/riq/:
	mkdir -p $@

$(name)/$(mapper)/:
	mkdir -p $@

$(name)/$(mapper)/$(quant_method)/:
	mkdir -p $@

$(name)/$(mapper)/$(quant_method)/$(de_method)/:
	mkdir -p $@


################################################################################
# Read Filtering
################################################################################
# reuse the data filtered between experiments?



phony_targets+= qc quality_filtering_and_report clean_quality_filtering_and_report_cleanup

ifdef min_read_len
	read_qual_filter_common_params+=min_len=$(min_read_len)
endif

# alias: stage1=qc=quality_filtering_and_report
qc: quality_filtering_and_report 

# TODO: improve robustness (no filtered reads)
# TODO:	signature=filtering parameters (if they are the same then avoid recomputation between experiments)  minlen=$(min_read_len) min_qual=$(min_qual) qual_perc=$(min_qu
quality_filtering_and_report: setup	$(STAGE1_OUT_FILES)
	$(call p_info,[DONE] Quality filtering)


ifeq ($(qc),none)
$(info QC disabled)
# QC is disabled (no report, no filtering)
%.f.fastq: 
	$(call p_info,Filtering disabled $(call fix_libname,$(notdir $*)))
	echo $(data_dir)/raw_data/$(raw_folder)$($(call fix_libname,$(notdir $*))_dir) $(name)/data$($(call fix_libname,$(notdir $*))_dir) $(name)/report/riq/
	$(foreach f,$($(call fix_libname,$(notdir $*))),ln -s $(abspath $(data_dir)/raw_data/$(raw_folder)$($(call fix_libname,$(notdir $*))_dir)/$f) $(name)/data$($(call fix_libname,$(notdir $*))_dir)/$(notdir $*).f.fastq)

# nothing to do
clean_quality_filtering_and_report_cleanup:

else
# SE 
#$(name)/data/%.f.fastq: 
%.f.fastq: 
	$(call p_info,Filtering $(call fix_libname,$(notdir $*)))
	$(call do_quality_filtering_and_report,$(call fix_libname,$(notdir $*)))
#	$(call not_empty,$@)


# Cleanup
clean_quality_filtering_and_report_cleanup:
	$(foreach p,$(se) $(pe),$(call do_quality_filtering_and_report_cleanup,$(p));)
endif

################################################################################
# Mapping
################################################################################
# All mapping files have the same name (but are placed in different folders)
# The mappings are placed in $(name)/$(mapper) with the suffix (se/pe)hits.bam

# ** TODO **
# 1. Use singleton reads if available  (f.sing.fastq file)
# 2. make mapping independent from the remaining steps...WIP

mapping: stage1 $(name)/$(mapper)/ $(mapper)_mapping
	$(call p_info,[DONE] Mapping)

print_stage2_files:
	echo $(STAGE2_OUT_FILES)

#*************
# Generic rule
#*************
#####################
phony_targets+= $(mapper)_mapping mapping stage2_tracks

$(mapper)_mapping: $(index_files) $(STAGE2_OUT_FILES)

stage2_tracks_targets=$(call rep_browse,$(subst .bam,.bam.tracks,$(STAGE2_OUT_FILES)))	

stage2_tracks: $(stage2_tracks_targets)
	$(call p_info,[DONE] Generated stage 2 tracks)

stage2_upload_tracks: $(subst .tracks,.tracks.uploaded,$(stage2_tracks_targets))
	$(call p_info,[DONE] Uploaded stage 2 tracks)

# 
mappingbyname: $(mapper)_mappingbyname

$(mapper)_mappingbyname: $(index_files) $(STAGE2BYNAME_OUT_FILES)

# interleaved fastq file
# special rule for GEM with PE
# 1-mapper
define mapper_ifiles=
$(if $(subst gem,,$(1)),$(3),$(name)/data/$(2)_int.f.fastq)
endef

##############################################
# Create the rules on the fly for each library
# $1 = libname
define make-se-bam-rule=
$(call lib2bam_folder,$(1))$(1).se.hits.bam: $(call lib2filt_folder,$(1))$(1).f.fastq $(index_files) $(gtf_file_abspath) $(reference_prefix) 
	$(call run_$(mapper)_map,$(1),$$<,$$@)
endef

define make-pe-bam-rule=
$(call lib2bam_folder,$(1))$(1).pe.hits.bam: $(call mapper_ifiles,$(mapper),$(1),$(call lib2filt_folder,$(1))$(1)_1.f.fastq $(call lib2filt_folder,$(1))$(1)_2.f.fastq)   $(index_files)
	$(call run_$(mapper)_map,$(1),$(call mapper_ifiles,$(mapper),$(1),$(call lib2filt_folder,$(1))$(1)_1.f.fastq $(call lib2filt_folder,$(1))$(1)_2.f.fastq),$$@)
endef

# create the output directories
$(foreach l,$(se) $(pe),$(eval $(shell mkdir -p $(call lib2bam_folder,$(l)))))

# rules for SE libraries
$(foreach l,$(se),$(eval $(call make-se-bam-rule,$(l))))
# rules for PE libraries
$(foreach l,$(pe),$(eval $(call make-pe-bam-rule,$(l))))

# interleaved fastq file
$(name)/data/%_int.f.fastq: $(name)/data/%_1.f.fastq $(name)/data/%_2.f.fastq
	fastq2interleaved.pl $^ $@.tmp && mv $@.tmp $@

%.$(mapper).index: %.fa

################################################################################
# Quantification
################################################################################

define genes_quant_files=
$(foreach p,$(pe), $(call lib2quant_folder,$(p))$(p).pe.genes.raw.$(quant_method).tsv) $(foreach s,$(se), $(call lib2quant_folder,$(s))$(s).se.genes.raw.$(quant_method).tsv)
endef

define exons_quant_file=
$(if $(filter y,$(exon_quant)),$(name)/$(mapper)/$(quant_method)/exons.raw.$(quant_method).tsv,)
endef
define exons_quant_files=
$(if $(filter y,$(exon_quant)),$(foreach p,$(pe),$(call lib2quant_folder,$(p))$(p).pe.exons.raw.$(quant_method).tsv) $(foreach s,$(se), $(call lib2quant_folder,$(s))$(s).se.exons.raw.$(quant_method).tsv),)
endef

define exons_quant_norm=
$(if $(filter y,$(exon_quant)),$(1),)
endef


define transcripts_quant_file=
$(if $(filter y,$(transcript_quant)),$(name)/$(mapper)/$(quant_method)/transcripts.raw.$(quant_method).tsv,)
endef

define transcripts_quant_files=
$(if $(filter y,$(transcript_quant)),$(foreach p,$(pe),$(call lib2quant_folder,$(p))$(p).pe.transcripts.raw.$(quant_method).tsv) $(foreach s,$(se), $(call lib2quant_folder,$(s))$(s).se.transcripts.raw.$(quant_method).tsv),)
endef

define transcripts_quant_norm=
$(if $(filter y,$(transcript_quant)),$(1),)
endef


define nquant_files=
$(name)/$(mapper)/$(quant_method)/genes.rpkm.$(quant_norm_method).tsv $(call exons_quant_file,$(name)/$(mapper)/$(quant_method)/exons.rpkm.$(quant_norm_method).tsv) $(call transcripts_quant_file,$(name)/$(mapper)/$(quant_method)/transcripts.rpkm.$(quant_norm_method).tsv)
endef

# Note
# The quantification may be produced at the level of genes, exons  or transcripts/isoforms
# The quantification can be simply counts (raw), f/rpkm (rpkm), or normalized by library size (nlib)
# The names of the TSV files produced have the format: <quant.level>.<type of quantification>.quant_method.tsv
# Ex. genes.raw.htseq1.tsv
#     exons.raw.htseq1.tsv
#     genes.nlib.htseq1.tsv

ifeq ($(quant_method),none) 
quantification:
	$(call p_info,[DISABLED] Assembly and quantification)
$(quant_method)_quant_files=
$(quant_method)_quant:
quantification_s:
else
$(quant_method)_quant_files=$(name)/$(mapper)/$(quant_method)/genes.raw.$(quant_method).tsv $(call transcripts_quant_file)  $(call exons_quant_file) 

STAGE3_S_TARGETS+=$(call genes_quant_files) $(call transcripts_quant_files)  $(call exons_quant_files)

# Raw  + Normalized 
quantification: $(quant_norm_method)_nquant $(quant_method)_quant 
	$(call p_info,[DONE] Assembly and quantification)

$(quant_method)_quant: mapping $($(quant_method)_quant_files)
# do not create the final matrix file (used by lsf wrapper)
quantification_s: $(STAGE3_S_TARGETS)

print_stage3_s_targets: $(STAGE3_S_TARGETS)
	echo $^

endif
phony_targets+= quantification $(quant_method)_quant quantification_s



#*****************
# Scripture 
#*****************

ifndef scripture_params
scripture_params= -minSpliceSupport 1
endif

define scripture_pe_file=
$(if $(strip $(pe)),$(1).paired.bam,)
endef

define scripture_pe_params=
$(if $(strip $(pe)),-pairedEnd $(1),)
endef
# run scripture for each chr
# extract the sequences
#                 1     2            3          4           5             6              7
# run_scripture (sam,tsv file,reference_dir,target_dir,pairend_option,annot.gtf,tsv file@extended bed)
define run_scripture=
	mkdir -p $(4)
	for chr in `cut -f 1 $(2)`; do  \
		scripture  $(scripture_params) -alignment $(1) -out $(4)/$$chr.segments -sizeFile $(2) -chr $$chr  -chrSequence $(3)/$$chr.fa $(5); \
	    scripture  -task score -in  $(4)/$$chr.segments -alignment $(1) -sizeFile $(2) -out $(4)/$$chr.score.tsv $(5);\
	done; 
	cat $(4)/*.score.tsv > $(7).tmp  && bedtools intersect -wb -b $(6) -a $(7).tmp | cut -f 15,29- a.tsv | sed -e "s/^\([0-9]*\).0.\(.*\)/\2\t\1/" > $(7).tmp2 &&\
	irap_naive_count.pl $(7).tmp2 $(7).exons $(7).genes && \
	mv $(7).exons $(7).exons.tsv && \
	mv $(7).genes $(7).genes.tsv  && \
	grep -v -e "(`cut -f 1 $(7).exons.tsv|sed 's/ /|/g'`)" $(gtf_file_abspath)| sed  "s/.*gene_id .\([^\"]*\).;.*/\1\t0/" >>  $(7).genes $(7).genes.tsv 
endef

phony_targets+= scripture_quant scripture_assembly scripture_setup scripture_assembly_lsf1

scripture_quant: mapping $(name)/$(mapper)/scripture/rawcounts.scripture.tsv
	$(call p_error,scripture assembly is working (use target scripture_assembly) but quantification is still under development)
#
# as recommend by scripture manual
scripture_assembly: $(name)/$(mapper)/scripture/rawcounts.all.scripture.tsv

scripture_setup: $(name)/$(mapper)/$(quant_method)/chr_size.tsv $(reference_abspath)_files

# only generate the bam files for each lib
scripture_assembly_lsf1: $(foreach p,$(pe),$(name)/$(mapper)/$(quant_method)/$(p).pe.$(quant_method).tsv) $(foreach s,$(se), $(name)/$(mapper)/$(quant_method)/$(s).se.$(quant_method).tsv)

$(name)/$(mapper)/scripture/rawcounts.all.scripture.tsv:  $(gtf_file_abspath) $(name)/$(mapper)/$(quant_method)/alignments.bam $(name)/$(mapper)/$(quant_method)/chr_size.tsv $(reference_abspath)_files    $(call scripture_pe_file,$(name)/$(mapper)/$(quant_method)/alignments.bam) 
	mkdir -p $(@D)/all
	$(call run_scripture,$(@D)/alignments.bam,$(@D)/chr_size.tsv,$(reference_abspath)_files,$(@D)/all, $(call scripture_pe_params,$(call scripture_pe_file,$(@D)/alignments.bam)),$(gtf_file_abspath),$@.tmp) && mv $@.tmp.genes.tsv $@


#
# for DE and normalization it may be better to have the counts file by file
$(name)/$(mapper)/scripture/rawcounts.scripture.tsv: $(foreach p,$(pe),$(name)/$(mapper)/$(quant_method)/$(p).pe.$(quant_method).tsv) $(foreach s,$(se), $(name)/$(mapper)/$(quant_method)/$(s).se.$(quant_method).tsv)
	( $(call pass_args_stdin,irap_merge_tsv.sh,$@,$^) ) > $@.tmp && mv $@.tmp $@

# SE & PE
$(name)/$(mapper)/scripture/%.se.scripture.tsv: $(name)/$(mapper)/%.se.hits.bam $(gtf_file_abspath) $(name)/$(mapper)/$(quant_method)/chr_size.tsv $(reference_abspath)_files   $(name)/$(mapper)/%.se.hits.bam.bai
	$(call run_scripture,$<,$(@D)/chr_size.tsv,$(reference_abspath)_files,$(@D)/$*,,$(gtf_file_abspath),$@.tmp) && mv $@.tmp.genes.tsv $@

$(name)/$(mapper)/scripture/%.pe.scripture.tsv: $(name)/$(mapper)/%.pe.hits.bam $(gtf_file_abspath) $(name)/$(mapper)/$(quant_method)/chr_size.tsv $(reference_abspath)_files   $(name)/$(mapper)/%.pe.hits.bam.bai
	$(call run_scripture,$<,$(@D)/chr_size.tsv,$(reference_abspath)_files,$(@D)/$*, -pairedEnd $<,$(gtf_file_abspath),$@.tmp) && mv $@.tmp.genes.tsv $@


$(name)/$(mapper)/$(quant_method)/alignments.bam: $(foreach p,$(pe),$(name)/$(mapper)/$(p).pe.hits.byname.bam) $(foreach s,$(se),$(name)/$(mapper)/$(s).se.hits.byname.bam)
	$(call samcat,$^) | samtools sort -m $(SAMTOOLS_SORT_MEM) -T $@.sorted -o $@.sorted.bam -  && mv  $@.sorted.bam $@  && samtools index $@


$(name)/$(mapper)/$(quant_method)/alignments.bam.paired.bam: $(foreach p,$(pe),$(name)/$(mapper)/$(p).pe.hits.byname.bam)
	$(call samcat,$^) | samtools sort  -m $(SAMTOOLS_SORT_MEM) -T $@.tmp -o $@.tmp.bam -  && mv $@.tmp.bam $@ && samtools index $@

#
#A 2-column tab separated file containing the chromosome name and size for the organism.
$(name)/$(mapper)/$(quant_method)/chr_size.tsv: $(reference_abspath).fai
	cut -f 1,2 $< > $@.tmp && mv $@.tmp $@

$(reference_abspath)_files: $(reference_abspath)
	irap_fasta_split.pl $< $@


################################################################################
# Normalization
################################################################################
$(quant_norm_method)_nquant_files=$(name)/$(mapper)/$(quant_method)/genes.nlib.$(quant_norm_method).tsv $(name)/$(mapper)/$(quant_method)/genes.rpkm.$(quant_norm_method).tsv $(call exons_quant_norm,$(name)/$(mapper)/$(quant_method)/exons.nlib.$(quant_norm_method).tsv $(name)/$(mapper)/$(quant_method)/exons.rpkm.$(quant_norm_method).tsv) $(call transcripts_quant_norm,$(name)/$(mapper)/$(quant_method)/transcripts.nlib.$(quant_norm_method).tsv $(name)/$(mapper)/$(quant_method)/transcripts.rpkm.$(quant_norm_method).tsv)

STAGE3_OUT_FILES+=$($(quant_method)_quant_files) $($(quant_norm_method)_nquant_files)

STAGE3_TSV_FILES=$(call exons_quant_files)\
	       $(call transcripts_quant_files)\
	       $(call genes_quant_files)\
	       $(call nquant_files)

##################
#

# which program to use to merge the tsv files
# 1 = quant_method
# TODO: reduce memory footprint of irap_merge_tsv_NA.sh 
define merge_tsv=
$(if $(findstring cufflinks,$(1)),irap_merge_tsv_NA.sh,irap_merge_tsv.sh)
endef

phony_targets+= $(quant_norm_method)_nquant

print_stage3_files:
	echo $(STAGE3_OUT_FILES)

$(quant_norm_method)_nquant: $(quant_method)_quant $($(quant_norm_method)_nquant_files)

# RPKM
# none method: irap computes the RPKMs based on the raw counts
$(name)/$(mapper)/$(quant_method)/genes.rpkm.none.tsv: $(name)/$(mapper)/$(quant_method)/genes.raw.$(quant_method).tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature gene --metric rpkm --out $@.tmp && mv $@.tmp $@	

$(name)/$(mapper)/$(quant_method)/exons.rpkm.none.tsv: $(name)/$(mapper)/$(quant_method)/exons.raw.$(quant_method).tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature exon --metric rpkm --out $@.tmp && mv $@.tmp $@	

$(name)/$(mapper)/$(quant_method)/transcripts.rpkm.none.tsv: $(name)/$(mapper)/$(quant_method)/transcripts.raw.$(quant_method).tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature transcript --metric rpkm --out $@.tmp && mv $@.tmp $@	

# special rules
# cufflinks*
$(name)/$(mapper)/$(quant_method)/genes.rpkm.cufflinks%.tsv: $(foreach p,$(pe),$(call lib2quant_folder,$(p))$(p).pe.genes.rpkm.$(quant_method).tsv) $(foreach s,$(se),$(call lib2quant_folder,$(s))$(s).se.genes.rpkm.$(quant_method).tsv) 
	( $(call pass_args_stdin,$(call merge_tsv,$(quant_method)),$@,$^) ) > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/transcripts.rpkm.cufflinks%.tsv: $(foreach p,$(pe),$(call lib2quant_folder,$(p))$(p).pe.transcripts.rpkm.$(quant_method).tsv) $(foreach s,$(se),$(call lib2quant_folder,$(s))$(s).se.transcripts.rpkm.$(quant_method).tsv) 
	( $(call pass_args_stdin,$(call merge_tsv,$(quant_method)),$@,$^) ) > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/exons.rpkm.cufflinks%.tsv:
	$(call p_info, Warning! Cufflinks does not produce quantification at exon level. Generating empty file $@.)
	@$(call empty_file,$@)

# flux-capacitor
$(name)/$(mapper)/$(quant_method)/genes.rpkm.flux%.tsv: $(foreach p,$(pe),$(call lib2quant_folder,$(p))$(p).pe.genes.rpkm.$(quant_method).tsv) $(foreach s,$(se),$(call lib2quant_folder,$(s))$(s).se.genes.rpkm.$(quant_method).tsv) 
	( $(call pass_args_stdin,$(call merge_tsv,$(quant_method)),$@,$^) )  > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/transcripts.rpkm.flux%.tsv: $(foreach p,$(pe),$(call lib2quant_folder,$(p))$(p).pe.transcripts.rpkm.$(quant_method).tsv) $(foreach s,$(se),$(call lib2quant_folder,$(s))$(s).se.transcripts.rpkm.$(quant_method).tsv) 
	( $(call pass_args_stdin,$(call merge_tsv,$(quant_method)),$@,$^) )  > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/exons.rpkm.flux%.tsv: 
	$(call p_info, Warning! Flux-capacitor does not produce quantification at exon level. Generating empty file $@.)
	@$(call empty_file,$@)

# nurd
$(name)/$(mapper)/nurd/genes.rpkm.nurd.tsv: $(foreach p,$(pe),$(call lib2quant_folder,$(p))$(p).pe.genes.rpkm.$(quant_method).tsv) $(foreach s,$(se), $(call lib2quant_folder,$(s))$(s).se.genes.rpkm.$(quant_method).tsv)
	( $(call pass_args_stdin,$(call merge_tsv,$(quant_method)),$@,$^) ) > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/nurd/transcripts.rpkm.nurd.tsv: $(foreach p,$(pe),$(call lib2quant_folder,$(p))$(p).pe.transcripts.rpkm.$(quant_method).tsv) $(foreach s,$(se),$(call lib2quant_folder,$(s))$(s).se.transcripts.rpkm.$(quant_method).tsv) 
	( $(call pass_args_stdin,$(call merge_tsv,$(quant_method)),$@,$^) ) > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/exons.rpkm.nurd.tsv: 
	$(call p_info, Warning! NURD does not produce quantification at exon level. Generating empty file $@.)
	@$(call empty_file,$@)


$(name)/$(mapper)/$(quant_method)/%.nlib.nurd.tsv:
	$(call p_info, Warning! Unable to generate  nlib file $@ with $(quant_method).)
	@$(call empty_file,$@)
$(name)/$(mapper)/$(quant_method)/%.nlib.nurd.tsv:
	$(call p_info, Warning! Unable to generate nlib file $@ with $(quant_method).)
	@$(call empty_file,$@)

#################################################################
# Disabled: just copy the file with the raw quantification values
$(name)/$(mapper)/$(quant_method)/%.nlib.none.tsv: $(name)/$(mapper)/$(quant_method)/%.raw.$(quant_method).tsv 
	$(call p_info,Quantification normalization disabled. Please set the quant_norm_method parameter if you do not want this behavior.)
	cp $< $@

#############
# HTSeq
#############

# htseq1 rpkm per gene
$(name)/$(mapper)/htseq1/genes.rpkm.htseq1.tsv: $(name)/$(mapper)/htseq1/genes.raw.htseq1.tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature gene --metric rpkm --out $@.tmp && mv $@.tmp $@


# htseq1 rpkm per transcript
$(name)/$(mapper)/htseq1/transcripts.rpkm.htseq1.tsv: $(name)/$(mapper)/htseq1/transcripts.raw.htseq1.tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature transcript --metric rpkm --out $@.tmp && mv $@.tmp $@

# htseq1 rpkm per exon
$(name)/$(mapper)/htseq1/exons.rpkm.htseq1.tsv: $(name)/$(mapper)/htseq1/exons.raw.htseq1.tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature exon --metric rpkm --out $@.tmp && mv $@.tmp $@


# htseq2 rpkm per gene
$(name)/$(mapper)/htseq2/genes.rpkm.htseq2.tsv: $(name)/$(mapper)/htseq2/genes.raw.htseq2.tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature gene --metric rpkm --out $@.tmp && mv $@.tmp $@


# htseq2 rpkm per transcript
$(name)/$(mapper)/htseq2/transcripts.rpkm.htseq2.tsv: $(name)/$(mapper)/htseq2/transcripts.raw.htseq2.tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature transcript --metric rpkm --out $@.tmp && mv $@.tmp $@

# htseq2 rpkm per exons
$(name)/$(mapper)/htseq2/exons.rpkm.htseq2.tsv: $(name)/$(mapper)/htseq2/exons.raw.htseq2.tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature exon --metric rpkm --out $@.tmp && mv $@.tmp $@


# rpkm+norm
ifneq ($(quant_norm_method),none)
ifneq (,$(filter $(quant_method),htseq1 htseq2))
$(name)/$(mapper)/$(quant_method)/genes.rpkm.$(quant_norm_method).tsv: $(name)/$(mapper)/$(quant_method)/genes.nlib.$(quant_norm_method).tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature gene --metric rpkm --out $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/exons.rpkm.$(quant_norm_method).tsv: $(name)/$(mapper)/$(quant_method)/exons.nlib.$(quant_norm_method).tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature exon --metric rpkm --out $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/transcripts.rpkm.$(quant_norm_method).tsv: $(name)/$(mapper)/$(quant_method)/transcripts.nlib.$(quant_norm_method).tsv $(feat_length)
	irap_raw2metric --tsv $<  --lengths $(feat_length) --feature transcript --metric rpkm --out $@.tmp && mv $@.tmp $@
endif
endif

#############
# Cufflinks1
#############
$(name)/$(mapper)/$(quant_method)/%.genes.rpkm.cufflinks1.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.genes.fpkm_tracking
	cut -f 1,10 $<  | tail -n +2  | grep -v CUFF  > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/cufflinks1_nd/%.genes.rpkm.cufflinks1_nd.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.genes.fpkm_tracking
	cut -f 1,10 $< | tail -n +2 > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/%.exons.rpkm.cufflinks1.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.gtf
	grep -w exon $< | grep -v CUFF | sed -e 's/.*gene_id .\([^\"]*\).; transcript_id .\([^\"]*\).; exon_number .\([^\"]*\).; FPKM .\([^\"]*\)..*/\1.\2.\3\t\4/' > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/%.exons.rpkm.cufflinks1_nd.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.gtf
	grep -w exon $<  | grep -v CUFF | sed -e 's/.*gene_id .\([^\"]*\).; transcript_id .\([^\"]*\).; exon_number .\([^\"]*\).; FPKM .\([^\"]*\)..*/\1.\2.\3\t\4/' > $@.tmp && mv $@.tmp $@

#
$(name)/$(mapper)/$(quant_method)/%.transcripts.rpkm.cufflinks1.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.isoforms.fpkm_tracking
	cut -f 1,10 $<  | tail -n +2  | grep -v CUFF > $@.tmp && mv $@.tmp $@
# 'new' genes can't appear in the tsv file otherwise the different files can't be merged

$(name)/$(mapper)/$(quant_method)/%.transcripts.rpkm.cufflinks1_nd.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.isoforms.fpkm_tracking
	cut -f 1,10 $<  | tail -n +2 > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/%.nlib.cufflinks1.tsv:
	$(call p_info, Warning! Unable to generate  nlib file $@ with $(quant_method).)
	@$(call empty_file,$@)
$(name)/$(mapper)/$(quant_method)/%.nlib.cufflinks1_nd.tsv:
	$(call p_info, Warning! Unable to generate nlib file $@ with $(quant_method).)
	@$(call empty_file,$@)

############
# Cufflinks2
############
$(name)/$(mapper)/$(quant_method)/%.genes.rpkm.cufflinks2.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.genes.fpkm_tracking
	cut -f 1,10 $<  | tail -n +2  |grep -v CUFF > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/cufflinks2/%.exons.rpkm.cufflinks2.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.gtf
	grep -w exon $<  | grep -v CUFF | sed -e 's/.*gene_id .\([^\"]*\).; transcript_id .\([^\"]*\).; exon_number .\([^\"]*\).; FPKM .\([^\"]*\)..*/\1.\2.\3\t\4/' > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/%.transcripts.rpkm.cufflinks2.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.isoforms.fpkm_tracking
	cut -f 1,10 $<  | tail -n +2  |grep -v CUFF  > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/%.genes.rpkm.cufflinks2_nd.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.genes.fpkm_tracking
	cut -f 1,10 $<  | tail -n +2  |grep -v CUFF > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/%.exons.rpkm.cufflinks2_nd.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.gtf
	grep -w exon $<  | grep -v CUFF | sed -e 's/.*gene_id .\([^\"]*\).; transcript_id .\([^\"]*\).; exon_number .\([^\"]*\).; FPKM .\([^\"]*\)..*/\1.\2.\3\t\4/' > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/%.transcripts.rpkm.cufflinks2_nd.tsv: $(name)/$(mapper)/$(quant_method)/%.cuff.isoforms.fpkm_tracking
	cut -f 1,10 $<  | tail -n +2  |grep -v CUFF  > $@.tmp && mv $@.tmp $@


$(name)/$(mapper)/$(quant_method)/%.nlib.cufflinks2.tsv:
	$(call p_info, Warning! Unable to  generate nlib file $@ with $(quant_method).)
	@$(call empty_file,$@)

$(name)/$(mapper)/$(quant_method)/%.nlib.cufflinks2_nd.tsv:
	$(call p_info, Warning! Unable to generate  nlib file $@ with $(quant_method).)
	@$(call empty_file,$@)

##################################
# Stringtie
$(name)/$(mapper)/$(quant_method)/%.nlib.stringtie.tsv:
	$(call p_info, Warning! Unable to generate  nlib file $@ with $(quant_method).)
	@$(call empty_file,$@)
$(name)/$(mapper)/$(quant_method)/%.nlib.strintie_nd.tsv:
	$(call p_info, Warning! Unable to generate nlib file $@ with $(quant_method).)
	@$(call empty_file,$@)

##################################
# DEseq - normalize by sample size
# nlib
# deseq_min_reads:=5
# Note: counts of technical replicates  have to be summed up into a single column
$(name)/$(mapper)/$(quant_method)/genes.nlib.deseq.tsv: $(name)/$(mapper)/$(quant_method)/genes.raw.$(quant_method).tsv
	irap_deseq_norm $<  > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/transcripts.nlib.deseq.tsv: $(name)/$(mapper)/$(quant_method)/transcripts.raw.$(quant_method).tsv
	irap_deseq_norm $<  > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/exons.nlib.deseq.tsv: $(name)/$(mapper)/$(quant_method)/exons.raw.$(quant_method).tsv
	irap_deseq_norm $<  > $@.tmp && mv $@.tmp $@


##################################
# EDGER
$(name)/$(mapper)/$(quant_method)/exons.nlib.edger.tsv:
	$(call p_error, Under implementation)
$(name)/$(mapper)/$(quant_method)/genes.nlib.edger.tsv:
	$(call p_error, Under implementation)
$(name)/$(mapper)/$(quant_method)/transcripts.nlib.edger.tsv:
	$(call p_error, Under implementation)

##################################
# VOOM
$(name)/$(mapper)/$(quant_method)/exons.nlib.voom.tsv:
	$(call p_error, Under implementation)
$(name)/$(mapper)/$(quant_method)/genes.nlib.voom.tsv:
	$(call p_error, Under implementation)
$(name)/$(mapper)/$(quant_method)/transcripts.nlib.voom.tsv:
	$(call p_error, Under implementation)

################
# flux-capacitor
# norm. already done in quant step...fix file names if necessary
# cufflinks1, cufflinks2, deseq and edger flux

$(name)/$(mapper)/$(quant_method)/genes.nlib.flux_cap.tsv: $(name)/$(mapper)/$(quant_method)/genes.raw.$(quant_method).tsv
	irap_deseq_norm $<  > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/transcripts.nlib.flux_cap.tsv: $(name)/$(mapper)/$(quant_method)/transcripts.raw.$(quant_method).tsv
	irap_deseq_norm $<  > $@.tmp && mv $@.tmp $@

$(name)/$(mapper)/$(quant_method)/exons.nlib.flux_cap.tsv: 
#	irap_deseq_norm $<  > $@.tmp && mv $@.tmp $@
	@$(call empty_file,$@)


################################################################################
# Differential Analysis
################################################################################
# TODO: consider DE at isoform level, exon level
ifeq (none,$(de_method))
STAGE4_OUT_FILES=
else
STAGE4_OUT_FILES=$(foreach cont,$(contrasts),$(name)/$(mapper)/$(quant_method)/$(de_method)/$(cont).genes_de.tsv)
endif
phony_targets+= DE de_files


DE: stage3 $(STAGE4_OUT_FILES)
	$(call p_info,[DONE] Differential analysis)

de_files:
	echo $(STAGE4_OUT_FILES)

#############################################################
# GSE
###########################################
# IRAP targets
# todo: mv this to the irap_gse file
ifeq (none,$(gse_tool))

GSE_OUT_FILES=

GSE:

else

GSE_OUT_FILES=$(subst _de.tsv,.gse.$(gse_tool).$(gse_method).go.tsv,$(STAGE4_OUT_FILES)) $(subst _de.tsv,.gse.$(gse_tool).$(gse_method).kegg.tsv,$(STAGE4_OUT_FILES))

GSE: DE $(GSE_OUT_FILES)
	$(call p_info,[DONE] GSE analysis)

endif

GSE_files:
	echo $(GSE_OUT_FILES)

phony_targets+= GSE GSE_files

#############################################################
## Cleanup
phony_targets+= clean full_clean clean_data_files

clean: clean_quality_filtering_and_report_cleanup 

full_clean: clean_data_files
	rm -fr $(name)/

clean_data_files:
	rm -rf $(SETUP_DATA_FILES) $(index_files) $(reference_abspath).fa

# TODO: archive (delete everything except the "main" output files for each stage
#
#############################################################
################################################################################
phony_targets+= stage0 stage1 stage2 stage3 stage3a stage3as stage3b stage4 stage5
silent_targets+= 

# alias - make it easier for the user
stage0: setup
stage1: setup quality_filtering_and_report
stage2: setup mapping
stage3: setup $(STAGE3_OUT_FILES)
stage3a: setup $(quant_method)_quant 
stage3as: setup quantification_s
#stage3b: setup stage3a
# deprecated
stage3b: setup $(shell rm -f $(name)/$(mapper)/$(quant_method)/rawcounts.$(quant_method).tsv) stage3a
stage4: setup DE
stage5: setup GSE

# deprecated: to be removed in the future
assemble: quantification


# *************
# Transcriptome (WIP)
# *************
%.trans.fa: $(reference_abspath) %.ref.gtf
	extract_transcripts $^ > $@

%.cdna_ncrna.fa: %.cdna.all.fa %.ncrna.fa
	cat $^ > $@

%.ref.gtf: %.gtf %.ncrna.fa
	filterGTF.rb  $*.ncrna.fa $< > $@

%.ref.gtf: %.ref.gff
	ensembl_gtf_to_gff.pl $< > $@

##############################################################################
# Reporting

phony_targets+= report
report: report_all_targets

###################################################
# Execution status
# Creates a status.tsv file with the completion status of each stage of the pipeline based on the files created
phony_targets+= status_html status stage2_tracks stage3_tracks stage4_tracks
status_html: $(name)/report/status.html
	$(call p_info,Created $<)

status: $(name)/$(name).status.tsv
	$(call p_info,Created $<)

### Tracks
define exclude_empty=
$(foreach f,$(1), $(if $(call is_empty_file,$(f)),,$(f)))
endef

define stage3_tracks_targets=
$(subst .tsv,.tsv.tracks,$(call exclude_empty,$(STAGE3_TSV_FILES)))
endef

stage3_tracks: $(call stage3_tracks_targets)
	$(call p_info,[DONE] Generated stage 3 tracks)

stage3_upload_tracks: $(subst .tracks,.tracks.uploaded,$(stage3_tracks_targets))
	$(call p_info,[DONE] Uploaded stage 3 tracks)

stage4_tracks_targets=$(subst .tsv,.tsv.tracks,$(STAGE4_OUT_FILES))

stage4_tracks: $(stage4_tracks_targets)
	$(call p_info,[DONE] Generated stage 4 tracks)

stage4_upload_tracks: $(subst .tracks,.tracks.uploaded,$(stage4_tracks_targets))
	$(call p_info,[DONE] Uploaded stage 4 tracks)


# target to generate some tracks
get_tracks: stage2_tracks stage3_tracks stage4_tracks 


########
# Status
include $(irap_path)/../aux/mk/irap_status.mk

#################
# Upgrade cleanup

cleanup_3_0: cleanup_3_0_data cleanup_3_0_reference

cleanup_3_0_data:
	rm -f $(name)/data/gene.annot.{tsv,Rdata}
# rpkm - force regeneration
	rm -f $(name)/*/*/*.rpkm.*

cleanup_3_0_reference:
	rm -f $(data_dir)/reference/$(species)/*gene.annot.{tsv,Rdata}
	rm -f $(data_dir)/reference/$(species)/*gene_annot.{tsv,Rdata}

##
cleanup_4_0: cleanup_4_0_data cleanup_4_0_reference

cleanup_4_0_data:
	rm -rf $(name)/report/quant/*
	rm -rf $(name)/report/qc*
	rm -rf $(name)/report/mapping/*


# the ids changed
cleanup_4_0_reference:
	rm -f $(gtf_file_abspath).exon_id.gtf

# 0.4.2d and above
tophat2_update_index: 
	$(call run_tophat2_index,$(word 1,$(files_indexed)))

tophat2_reuse_index:
	ln -s $(call tophat2_trans_index_filename_old,$(reference_abspath)) $(call tophat2_trans_index_filename,$(reference_abspath))
# cp the gff3 file to the new location
# 0.4.3d and above
gff3_update: $(data_dir)/reference/$(species)/$(notdir $(gff3_file_abspath))
	cp -a $(data_dir)/reference/$(species)/$(notdir $(gff3_file)) $(name)/data/$(notdir $(gff3_file))
	cp -a $(data_dir)/reference/$(species)/$(notdir $(juncs_file_abspath)) $(name)/data/$(notdir $(juncs_file_abspath))

###################################################
# 
#$(name)/report/all_options.txt:
#	( $(foreach v, $(call interesting_vars), $(v) = $($(v)))) ) > /dev/stdout

#define pprint_var
#
#echo "$(1) = $($(1))"
#
#endef
#define interesting_vars=
#$(filter-out %_sd %_rs $(se) $(pe),$(foreach v,$(.VARIABLES),$(if $(subst file,,$(#origin $(v))),,$(v) )))
#endef

###################################################
# Alternative targets (lightweight)
do_index: setup_dirs $(word 1,$(index_files))

# TODO: rename the BAM file and add the headers if necessary
do_mapping: $(mapper)_mapping

###################################################
phony_targets+= save_cache 
save_cache: 
	($(call list_cached_vars)) > $(cached_vars_file).tmp && mv $(cached_vars_file).tmp $(cached_vars_file)

###################################################
# FORCE the program to run even if files haven't changed
FORCE:


#PHONY: performance improvement. Tell MAKE that those targets don't generate any files. 
.PHONY:  $(phony_targets)
.SILENT: $(silent_targets)

###################################################
